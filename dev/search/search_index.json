{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TaxoTagger","text":"<p>TaxoTagger is an open-source Python library for DNA taxonomy identification, which involves categorizing DNA sequences into their respective taxonomic groups. It is powered by deep learning and semantic search to provide efficient and accurate results.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\ude80 Build vector databases from DNA sequences with ease</li> <li>\u26a1 Conduct efficient semantic searches for precise results</li> <li>\ud83d\udee0 Extend support for custom embedding models effortlessly</li> <li>\ud83c\udf10 Interact seamlessly through a user-friendly web app</li> </ul>"},{"location":"#webapp-demo","title":"Webapp Demo","text":""},{"location":"#citation","title":"Citation","text":"Citation <p>If you use TaxoTagger and/or its webapp in your work, please cite it as follows:</p> <p><pre><code>@software{Geng_TaxoTagger,\nauthor = {Geng, Cunliang},\nlicense = {Apache-2.0},\ntitle = {{TaxoTagger}},\nurl = {https://github.com/MycoAI/taxotagger},\nversion = {0.0.1-alpha.6}\n}\n</code></pre> Or check the CITATION file in the repo for more details.</p>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>Python \u22653.10</li> <li>Conda (optional but recommended)</li> </ul>"},{"location":"install/#install-from-pypi","title":"Install from PyPI","text":"Install taxotagger package<pre><code># create an virtual environment\nconda create -n venv-3.10 python=3.10\nconda activate venv-3.10\n\n# install the package (pre-release)\npip install --pre taxotagger  # (1)!\n</code></pre> <ol> <li>Taxotagger might be released as pre-release. To install the pre-release, you need the <code>--pre</code> option. </li> </ol>"},{"location":"install/#install-from-source-code","title":"Install from source code:","text":"Install from this repo<pre><code># create an virtual environment\nconda create -n venv-3.10 python=3.10\nconda activate venv-3.10\n\n# install from the source code\npip install git+https://github.com/MycoAI/taxotagger\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#build-a-vector-database","title":"Build a vector database","text":"Build a vector database from a FASTA file<pre><code>from taxotagger import ProjectConfig\nfrom taxotagger import TaxoTagger\n\nconfig = ProjectConfig()\ntt = TaxoTagger(config)\n\ntt.create_db('data/database.fasta') # (1)!\n</code></pre> <ol> <li>The data is available in the repo.</li> </ol> <p>Run the code above, you will see the following messages:</p> <pre><code>[2024-08-22 09:45:42] INFO     Embedding the DNA sequences in data/database.fasta using the model MycoAI-CNN                              taxotagger.py:69\nDownloading https://zenodo.org/records/10904344/files/MycoAI-CNN.pt to ~/.cache/mycoai\nDownloading MycoAI-CNN.pt \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 100% 0:00:00\n[2024-08-22 09:46:06] INFO     Loading model MycoAI-CNN from ~/.cache/mycoai/MycoAI-CNN.pt                                                utils.py:97\n[2024-08-22 09:46:12] INFO     Creating vector database for the DNA sequences in data/database.fasta at ~/.cache/mycoai/MycoAI-CNN.db     taxotagger.py:199\n[2024-08-22 09:47:21] INFO     Database created successfully at ~/.cache/mycoai/MycoAI-CNN.db                                             taxotagger.py:230\n</code></pre> <p>By default,  the <code>~/.cache/mycoai</code> folder is used to store the vector database and the embedding model. The <code>MycoAI-CNN.pt</code> model is automatically downloaded to this folder if it is not there, and the vector database is created and named after the model.</p> <p>You can use a different embedding model by specifying the model name:</p> Using a different embedding model<pre><code>tt.create_db('data/database.fasta', model_id='other_model_name') # (1)!\n</code></pre> <ol> <li>Just the name of the model without the <code>.pt</code> extension.</li> </ol> <p>You may want to integrate TaxoTagger with your own embedding model. See the Custom Embedding Models guide for more details.</p>"},{"location":"quickstart/#semantic-searching","title":"Semantic searching","text":"<p>After building the vector database, you can conduct a semantic search with a query FASTA file:</p> Conduct a semantic search with FASTA file<pre><code>from taxotagger import ProjectConfig\nfrom taxotagger import TaxoTagger\n\nconfig = ProjectConfig()\ntt = TaxoTagger(config)\n\nres = tt.search('data/query.fasta', limit=1) # (1)!\n</code></pre> <ol> <li>The <code>limit</code> parameter specifies the number of top results to return for each query sequence. If you want to return the top 3 results, you can set <code>limit=3</code>.</li> </ol> <p>The <code>data/query.fasta</code> file contains two query sequences: <pre><code>&gt;KY106088|k__Fungi;p__Ascomycota;c__Saccharomycetes;o__Saccharomycetales;f__Saccharomycetaceae;g__Zygotorulaspora;s__Zygotorulaspora_mrakii|SH1312607.09FU\nGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTATAGAAAAAAATGGAAGGGCCATGCGCTTAATTGCGCGGGCCCTCTCTTATTCACACGATGGAGACGAATATCTTCCTGCTTAGGGGCACGAGGCTTGGACCGAGTGGCCCGGCAGACACAAACACAAACAAATTTTTTTTGAATTTACGAATTAAAAAGAGTCAAAAACAAAATAAAAACAAAATATACCAAAACTTTCAACAACGGATCTCTTGGTTCTCGCACCGATGAAGAACGCAGCGAAATGCGATACGTAATGTGAATTGCAGAATTCCGTGAATCATCGAATCTTTGAACGCACATTGCGCCCCTTGGTATTCCAGGGGGCATGCCTGTTTGAGCGTCATTTCCTTCTCAAACACACGGTGTTTGGTGGTGAGTGATACTCTTTCTGGGAGTTAGCTTGAAAGTGTGAGCCCGTGGACTGCTCTTTTTGCTGTAGGCGGAAAAAAGTCGTGCTAGGTAACCACCAACTCGACGGACGTTCGGCCGACAAGGAAAACGGGGCGGTCGGGTCAACAGACACACATCAACGCTTGACCTCAAATCAGGTAGGAATACCCGCTGAACTTAAGCATATCAATAAGCGGA\n&gt;KY106087|k__Fungi;p__Ascomycota;c__Saccharomycetes;o__Saccharomycetales;f__Saccharomycetaceae;g__Zygotorulaspora;s__Zygotorulaspora_mrakii|SH1312607.09FU\nAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTATAGAAAAAAATGGAAGGGCCATGCGCTTAATTGCGCGGGCCCTCTCTTATTCACACGATGGAGACGAATATCTTCCTGCTTAGGGGCACGAGGCTTGGACCGAGTGGCCCGGCAGACACAAACACAAACAAATTTTTTTTGAATTTACGAATTAAAAAGAGTCAAAAACAAAATAAAAACAAAATATACCAAAACTTTCAACAACGGATCTCTTGGTTCTCGCACCGATGAAGAACGCAGCGAAATGCGATACGTAATGTGAATTGCAGAATTCCGTGAATCATCGAATCTTTGAACGCACATTGCGCCCCTTGGTATTCCAGGGGGCATGCCTGTTTGAGCGTCATTTCCTTCTCAAACACACGGTGTTTGGTGGTGAGTGATACTCTTTCTGGGAGTTAGCTTGAAAGTGTGAGCCCGTGGACTGCTCTTTTTGCTGTAGGCGGAAAAAAGTCGTGCTAGGTAACCACCAACTCGACGGACGTTCGGCCGACAAGGAAAACGGGGCGGTCGGGTCAACAGACACACATCAACGCTTGACCTCAAATCAGGTAGGAATACCCGCTGAACTTAAGCATATCAA\n</code></pre></p> <p>The search results <code>res</code> will be a dictionary with taxonomic level names as keys and matched results as values for each of the two query sequences. For example, <code>res['phylum']</code> will look like:</p> Search results for phylum<pre><code>[\n    [{\"id\": \"KY106088\", \"distance\": 1.0, \"entity\": {\"phylum\": \"Ascomycota\"}}],\n    [{\"id\": \"KY106087\", \"distance\": 0.9999998807907104, \"entity\": {\"phylum\": \"Ascomycota\"}}]\n]\n</code></pre> <p>The first inner list is the top results for the first query sequence, and the second inner list is the top results for the second query sequence.</p> <p>The <code>id</code> field is the sequence ID of the matched sequence. The <code>distance</code> field is the cosine similarity between the query sequence and the matched sequence with a value between 0 and 1, the closer to 1, the more similar. The <code>entity</code> field is the taxonomic information of the matched sequence. </p> <p>We can see that the top 1 results for both query sequences are exactly themselves. This is because the query sequences are also in the database. You can try with different query sequences to see the search results.</p>"},{"location":"quickstart/#project-configuration","title":"Project configuration","text":"<p>The <code>ProjectConfig</code> class is used to configure the project settings. </p> <p>You can change the settings by creating an instance of the class and setting the attributes:</p> Change project settings after creating the instance<pre><code>from taxotagger import ProjectConfig\n\nconfig = ProjectConfig()\n\n# Change cache folder\nconfig.mycoai_home = '~/temp_dir' \n\n# Use GPU for computation\nconfig.device = 'cuda'\n\n# Force re-download and reload embedding model\nconfig.force_reload = True\n\n# Set the log level to DEBUG\nconfig.log_level = 'DEBUG'\n\n# Log to a file\nconfig.log_file = '~/taxotagger.log'\n\n# Do not log to console\nconfig.log_to_console = False\n</code></pre> <p>Or you can set the attributes directly when creating the instance: Change project settings when creating the instance<pre><code>from taxotagger import ProjectConfig\n\nconfig = ProjectConfig(\n    mycoai_home='~/temp_dir',\n    device='cuda',\n    force_reload=True,\n    log_level='DEBUG',\n    log_file='~/taxotagger.log',\n    log_to_console=False\n)\n</code></pre></p> <p>After creating the instance, you can pass the <code>config</code> object to the <code>TaxoTagger</code> class to use the settings:</p> Pass the config object to the TaxoTagger class<pre><code>from taxotagger import TaxoTagger\n\ntt = TaxoTagger(config)\n</code></pre> <p>Tip</p> <p>The settings are read only when creating the <code>TaxoTagger</code> instance. </p> <p>So if you change the settings after creating the instance, the changes will not take effect. You need to create a new <code>TaxoTagger</code> instance with the updated settings.</p>"},{"location":"quickstart/#use-custom-embedding-models","title":"Use custom embedding models","text":"<p>You can use your own embedding models with TaxoTagger, such as using pre-trained models like transformers or creating domain-specific embeddings to enhance search accuracy. For that, please check the Custom Embedding Models guide.</p>"},{"location":"quickstart/#use-webapp","title":"Use webapp","text":"<p>You can use the TaxoTagger webapp to interact with the library seamlessly.  The webapp provides a user-friendly interface to conduct semantic searches and visualize the search results. On how to deploy and use the webapp, please check the TaxoTagger Webapp guide.</p>"},{"location":"webapp/","title":"TaxoTagger Webapp","text":"<p>TaxoTagger webapp is a user-friendly interface for the TaxoTagger library. It allows users to interact with the TaxoTagger library through a web browser. Users can upload DNA sequences and search for the taxonomy of the sequences using the TaxoTagger library.</p> <p>The webapp is available at https://github.com/MycoAI/taxotagger-webapp.</p> <p>Below are the instructions to deploy and use the webapp.</p>"},{"location":"webapp/#deployment-for-exploration","title":"Deployment for exploration","text":""},{"location":"webapp/#installation","title":"Installation","text":"<ol> <li> <p>Clone the repository to your local machine <pre><code>git clone https://github.com/MycoAI/taxotagger-webapp.git\n</code></pre></p> </li> <li> <p>Install the required packages <pre><code># Go to the taxotagger-webapp directory\ncd taxotagger-webapp\n\n# Create a new conda environment `taxotagger-webapp`\nconda create -n taxotagger-webapp python=3.10\n\n# Go to the conda environment\nconda activate taxotagger-webapp\n\n# Install the required packages\npip install -r requirements.txt\n</code></pre></p> </li> </ol>"},{"location":"webapp/#run-the-webapp","title":"Run the webapp","text":"<ol> <li> <p>Set the environment variables <code>MYCOAI_HOME</code></p> Linux or MacOSWindows <pre><code>export MYCOAI_HOME=/your/path/to/taxotagger-webapp/data\n</code></pre> <pre><code>set MYCOAI_HOME=C:\\your\\path\\to\\taxotagger-webapp\\data\n</code></pre> <p>Set the environment variable <code>MYCOAI_HOME</code> to the path of the <code>data</code> directory of your local webapp repository. The <code>data</code> directory contains the example vector databases for demo purposes.</p> </li> <li> <p>Start the webapp</p> <pre><code>streamlit run app.py # (1)!\n</code></pre> <ol> <li>Make sure you are in the <code>taxotagger-webapp</code> directory and the right conda environment is activated.</li> </ol> <p>Then you can open the webapp in your browser by visiting the URL http://localhost:8501.</p> <p>Note</p> <p>For the first time running, the webapp will download the embedding model files. This may take a few minutes depending on the internet connection speed.</p> </li> </ol>"},{"location":"webapp/#production-deployment","title":"Production deployment","text":"<p>The vector databases provided in the <code>data</code> directory are for demo purposes only.  To use the webapp in production, you should prepare the vector databases using the production data.  To build the vector database, you can follow the instructions in the Build a vector database page.</p>"},{"location":"api/abc/","title":"Base classes","text":""},{"location":"api/abc/#taxotagger.abc","title":"taxotagger.abc","text":""},{"location":"api/abc/#taxotagger.abc.EmbedModelBase","title":"EmbedModelBase","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for embedding models.</p>"},{"location":"api/abc/#taxotagger.abc.EmbedModelBase.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the pretrained model used for embedding.</p>"},{"location":"api/abc/#taxotagger.abc.EmbedModelBase.embed","title":"embed  <code>abstractmethod</code>","text":"<pre><code>embed(fasta_file: str) -&gt; dict[str, list[dict[str, Any]]]\n</code></pre> <p>Calculate the embeddings for the given FASTA file.</p> <p>Parameters:</p> <ul> <li> <code>fasta_file</code>               (<code>str</code>)           \u2013            <p>The path to the FASTA file to embed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, list[dict[str, Any]]]</code>           \u2013            <p>A dictionary of embeddings for each taxonomy level. The dictionary keys are the taxonomy levels, and the values are lists of dictionaries containing the id, embeddings and metadata for each sequence.</p> <p>The shape of the list is <code>(n_samples)</code>, where <code>n_samples</code> is the number of sequences.</p> <p>The keys <code>id</code> and <code>vector</code> must be present in the inside dictionaries to present the accession and the embedding vector of the sequence, respectively.</p> <p>For example: <pre><code>{\n    \"phylum\": [\n        {\"id\": \"seq1\", \"vector\": [0.1, 0.2, ...], \"phylum\": \"Ascomycota\", ...},\n        {\"id\": \"seq2\", \"vector\": [0.3, 0.4, ...], \"phylum\": \"Basidiomycota\", ...},\n        ...\n    ],\n    \"class\": [\n        {\"id\": \"seq1\", \"vector\": [0.5, 0.6, ...], \"class\": \"Dothideomycetes\", ...},\n        {\"id\": \"seq2\", \"vector\": [0.7, 0.8, ...], \"class\": \"Agaricomycetes\", ...},\n        ...\n    ],\n    ...\n}\n</code></pre></p> </li> </ul> Source code in <code>src/taxotagger/abc.py</code> <pre><code>@abstractmethod\ndef embed(self, fasta_file: str) -&gt; dict[str, list[dict[str, Any]]]:\n    \"\"\"Calculate the embeddings for the given FASTA file.\n\n    Args:\n        fasta_file: The path to the FASTA file to embed.\n\n    Returns:\n        A dictionary of embeddings for each taxonomy level.\n            The dictionary keys are the [taxonomy levels][taxotagger.defaults.TAXONOMY_LEVELS],\n            and the values are lists of dictionaries containing the id, embeddings and metadata\n            for each sequence.\n\n            The shape of the list is `(n_samples)`, where `n_samples` is the number of sequences.\n\n            The keys `id` and `vector` must be present in the inside dictionaries to present the\n            accession and the embedding vector of the sequence, respectively.\n\n            For example:\n            ```python\n            {\n                \"phylum\": [\n                    {\"id\": \"seq1\", \"vector\": [0.1, 0.2, ...], \"phylum\": \"Ascomycota\", ...},\n                    {\"id\": \"seq2\", \"vector\": [0.3, 0.4, ...], \"phylum\": \"Basidiomycota\", ...},\n                    ...\n                ],\n                \"class\": [\n                    {\"id\": \"seq1\", \"vector\": [0.5, 0.6, ...], \"class\": \"Dothideomycetes\", ...},\n                    {\"id\": \"seq2\", \"vector\": [0.7, 0.8, ...], \"class\": \"Agaricomycetes\", ...},\n                    ...\n                ],\n                ...\n            }\n            ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/config/","title":"Configuration","text":""},{"location":"api/config/#taxotagger","title":"taxotagger","text":""},{"location":"api/config/#taxotagger.ProjectConfig","title":"ProjectConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for the project.</p> <p>Attributes:</p> <ul> <li> <code>mycoai_home</code>               (<code>str</code>)           \u2013            <p>The working directory for the project. Downloads and cache files are stored here. Defaults to <code>~/.cache/mycoai</code>.</p> <p>You can also set the <code>MYCOAI_HOME</code> environment variable to override this, e.g. on Linux or macOS: <code>export MYCOAI_HOME=\"~/mycoai\"</code>.</p> </li> <li> <code>device</code>               (<code>str</code>)           \u2013            <p>The device to run the model on. Defaults to <code>\"cpu\"</code>.</p> <p>Available options are:</p> <ul> <li><code>\"cpu\"</code>: when no GPU is available,</li> <li><code>\"cuda\"</code>: when NVIDIA GPUs are available, use \"cuda:0\" to use the first GPU</li> <li><code>\"mps\"</code>: when Mac GPUs are available</li> <li>and any other valid PyTorch device</li> </ul> <p>For more information, see the PyTorch documentation.</p> </li> <li> <code>force_reload</code>               (<code>bool</code>)           \u2013            <p>Whether to force reload the model. Defaults to <code>False</code>.</p> </li> <li> <code>log_level</code>               (<code>Literal['NONSET', 'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']</code>)           \u2013            <p>The log level. Use the logging module's log level constants. Defaults to <code>\"INFO\"</code>.</p> </li> <li> <code>log_file</code>               (<code>str</code>)           \u2013            <p>The file to write the log to. If the file is an empty string (by default), the log will not be written to a file. If the file does not exist, it will be created. The log will be written to the file in append mode.</p> </li> <li> <code>log_to_console</code>               (<code>bool</code>)           \u2013            <p>Whether to log to the console. Defaults to <code>True</code>.</p> </li> </ul> <p>Examples:</p> <p>Get the default configuration</p> <pre><code>&gt;&gt;&gt; config = ProjectConfig()\n&gt;&gt;&gt; print(config)\n</code></pre> <p>Set the working directory to \"~/mycoai\"</p> <pre><code>&gt;&gt;&gt; config = ProjectConfig(mycoai_home=\"~/mycoai\")\n&gt;&gt;&gt; print(config.mycoai_home)\n</code></pre>"},{"location":"api/config/#taxotagger.ProjectConfig.mycoai_home","title":"mycoai_home  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mycoai_home: str = Field(\n    default_factory=lambda: expanduser(\n        getenv(ENV_MYCOAI_HOME, DEFAULT_CACHE_DIR)\n    ),\n    min_length=1,\n)\n</code></pre>"},{"location":"api/config/#taxotagger.ProjectConfig.device","title":"device  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>device: str = Field(default='cpu', min_length=1)\n</code></pre>"},{"location":"api/config/#taxotagger.ProjectConfig.force_reload","title":"force_reload  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>force_reload: bool = Field(default=False, strict=True)\n</code></pre>"},{"location":"api/config/#taxotagger.ProjectConfig.log_level","title":"log_level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_level: Literal[\n    \"NONSET\",\n    \"DEBUG\",\n    \"INFO\",\n    \"WARNING\",\n    \"ERROR\",\n    \"CRITICAL\",\n] = Field(default=\"INFO\")\n</code></pre>"},{"location":"api/config/#taxotagger.ProjectConfig.log_file","title":"log_file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_file: str = Field(default='')\n</code></pre>"},{"location":"api/config/#taxotagger.ProjectConfig.log_to_console","title":"log_to_console  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_to_console: bool = Field(default=True, strict=True)\n</code></pre>"},{"location":"api/defaults/","title":"Defaults","text":""},{"location":"api/defaults/#taxotagger.defaults","title":"taxotagger.defaults","text":"<p>This module contains the default values for this TaxoTagger library.</p>"},{"location":"api/defaults/#taxotagger.defaults.DEFAULT_CACHE_DIR","title":"DEFAULT_CACHE_DIR  <code>module-attribute</code>","text":"<pre><code>DEFAULT_CACHE_DIR = '~/.cache/mycoai'\n</code></pre> <p>The default directory for storing downloads and cache files.</p> <p>This is a constant and should not be modified.</p>"},{"location":"api/defaults/#taxotagger.defaults.ENV_MYCOAI_HOME","title":"ENV_MYCOAI_HOME  <code>module-attribute</code>","text":"<pre><code>ENV_MYCOAI_HOME = 'MYCOAI_HOME'\n</code></pre> <p>The environment variable name to set the working directory for the project.</p> <p>If it is not set, the default directory <code>DEFAULT_CACHE_DIR</code> will be used.</p> <p>On Linux or macOS, you can set the environment variable as follows: <pre><code>export MYCOAI_HOME=\"~/mycoai\"\n</code></pre></p> <p>Or in python, you can set it as follows: <pre><code>import os\nos.environ[\"MYCOAI_HOME\"] = \"~/mycoai\"\n</code></pre></p>"},{"location":"api/defaults/#taxotagger.defaults.PRETRAINED_MODELS","title":"PRETRAINED_MODELS  <code>module-attribute</code>","text":"<pre><code>PRETRAINED_MODELS = {\n    \"MycoAI-CNN\": \"https://zenodo.org/records/10904344/files/MycoAI-CNN.pt\",\n    \"MycoAI-BERT\": \"https://zenodo.org/records/10904344/files/MycoAI-BERT.pt\",\n}\n</code></pre> <p>Pretrained models and their download URLs.</p> <p>The keys are the model names, and the values are the download URLs. The names should be unique and  should not contain any spaces. The download URLs should be direct download links to the model files, and the name of the downloaded file should be the same as the model name.</p>"},{"location":"api/defaults/#taxotagger.defaults.TAXONOMY_LEVELS","title":"TAXONOMY_LEVELS  <code>module-attribute</code>","text":"<pre><code>TAXONOMY_LEVELS = [\n    \"phylum\",\n    \"class\",\n    \"order\",\n    \"family\",\n    \"genus\",\n    \"species\",\n]\n</code></pre> <p>The list of taxonomy level names used in this package.</p>"},{"location":"api/defaults/#taxotagger.defaults.MAX_BATCH_SIZE_BYTES","title":"MAX_BATCH_SIZE_BYTES  <code>module-attribute</code>","text":"<pre><code>MAX_BATCH_SIZE_BYTES = 64 * 1024 * 1024\n</code></pre> <p>The maximum batch size in bytes for the Milvus database.</p> <p>Milvus has a limit of 64MB for input and output per RPC operation, including <code>insert</code>, <code>search</code>, and <code>query</code> operations.</p> <p>For more information, see the Milvus documentation.</p>"},{"location":"api/logger/","title":"Logging","text":""},{"location":"api/logger/#taxotagger","title":"taxotagger","text":""},{"location":"api/logger/#taxotagger.setup_logging","title":"setup_logging","text":"<pre><code>setup_logging(\n    level: str = \"INFO\",\n    file: str = \"\",\n    to_console: bool = True,\n) -&gt; None\n</code></pre> <p>Setup logging configuration for the ancestor logger \"taxotagger\".</p> <p>Parameters:</p> <ul> <li> <code>level</code>               (<code>str</code>, default:                   <code>'INFO'</code> )           \u2013            <p>The log level, use the logging module's log level constants. Valid levels are: <code>NOTSET</code>, <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, <code>CRITICAL</code>.</p> </li> <li> <code>file</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The file to write the log to. If the file is an empty string (by default), the log will not be written to a file. If the file does not exist, it will be created. The log will be written to the file in append mode.</p> </li> <li> <code>to_console</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to log to the console.</p> </li> </ul> Source code in <code>src/taxotagger/logger.py</code> <pre><code>def setup_logging(\n    level: str = \"INFO\",\n    file: str = \"\",\n    to_console: bool = True,\n) -&gt; None:\n    \"\"\"Setup logging configuration for the ancestor logger \"taxotagger\".\n\n    Args:\n        level: The log level, use the logging module's log level constants.\n            Valid levels are: `NOTSET`, `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`.\n        file: The file to write the log to.\n            If the file is an empty string (by default), the log will not be written to a file.\n            If the file does not exist, it will be created.\n            The log will be written to the file in append mode.\n        to_console: Whether to log to the console.\n    \"\"\"\n    # Get the ancestor logger \"taxotagger\"\n    logger = logging.getLogger(\"taxotagger\")\n    logger.setLevel(level)\n    logger.handlers.clear()\n\n    # File handler\n    if file:\n        logger.addHandler(\n            RichHandler(\n                # force line wrapping at 200 characters, otherwise it will wrap at the console width\n                console=Console(file=open(file, \"a\"), width=200),\n                omit_repeated_times=False,\n                rich_tracebacks=True,\n                tracebacks_show_locals=True,\n                log_time_format=\"[%Y-%m-%d %X]\",\n                markup=True,\n            )\n        )\n\n    # Console handler\n    if to_console:\n        logger.addHandler(\n            RichHandler(\n                omit_repeated_times=False,\n                rich_tracebacks=True,\n                tracebacks_show_locals=True,\n                log_time_format=\"[%Y-%m-%d %X]\",\n                markup=True,\n            )\n        )\n</code></pre>"},{"location":"api/models/","title":"Embedding Models","text":""},{"location":"api/models/#taxotagger.models","title":"taxotagger.models","text":""},{"location":"api/models/#taxotagger.models.ModelFactory","title":"ModelFactory","text":"<p>Factory class to get the embedding model for the given model identifier.</p>"},{"location":"api/models/#taxotagger.models.ModelFactory.get_model","title":"get_model  <code>staticmethod</code>","text":"<pre><code>get_model(\n    model_id: str, config: ProjectConfig\n) -&gt; EmbedModelBase\n</code></pre> <p>Get the embedding model for the given model identifier.</p> <p>Parameters:</p> <ul> <li> <code>model_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the model to load.</p> </li> <li> <code>config</code>               (<code>ProjectConfig</code>)           \u2013            <p>The configurations for the project.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>EmbedModelBase</code>           \u2013            <p>The embedding model instance for the given model identifier.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; config = ProjectConfig()\n&gt;&gt;&gt; model = ModelFactory.get_model(\"MycoAI-CNN\", config)\n</code></pre> Source code in <code>src/taxotagger/models.py</code> <pre><code>@staticmethod\ndef get_model(model_id: str, config: ProjectConfig) -&gt; EmbedModelBase:\n    \"\"\"Get the embedding model for the given model identifier.\n\n    Args:\n        model_id: The identifier of the model to load.\n        config: The configurations for the project.\n\n    Returns:\n        The embedding model instance for the given model identifier.\n\n    Examples:\n        &gt;&gt;&gt; config = ProjectConfig()\n        &gt;&gt;&gt; model = ModelFactory.get_model(\"MycoAI-CNN\", config)\n    \"\"\"\n    if model_id == \"MycoAI-CNN\":\n        return MycoAICNNEmbedModel(config)\n    elif model_id == \"MycoAI-BERT\":\n        return MycoAIBERTEmbedModel(config)\n    # Add more embedding models here if needed\n    else:\n        raise ValueError(\n            f\"Invalid model id {model_id}. Valid models are {PRETRAINED_MODELS.keys()}\"\n        )\n</code></pre>"},{"location":"api/models/#taxotagger.models.MycoAICNNEmbedModel","title":"MycoAICNNEmbedModel","text":"<pre><code>MycoAICNNEmbedModel(config: ProjectConfig)\n</code></pre> <p>               Bases: <code>EmbedModelBase</code></p> <p>Embedding model for the pretrained MycoAI-CNN.</p> Source code in <code>src/taxotagger/models.py</code> <pre><code>def __init__(self, config: ProjectConfig) -&gt; None:\n    self._config = config\n    self.model = load_model(self.name, config)\n</code></pre>"},{"location":"api/models/#taxotagger.models.MycoAICNNEmbedModel.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'MycoAI-CNN'\n</code></pre>"},{"location":"api/models/#taxotagger.models.MycoAICNNEmbedModel.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = load_model(name, config)\n</code></pre>"},{"location":"api/models/#taxotagger.models.MycoAICNNEmbedModel.embed","title":"embed","text":"<pre><code>embed(fasta_file: str) -&gt; dict[str, list[dict[str, Any]]]\n</code></pre> <p>Calculate the embeddings for the given FASTA file.</p> <p>Parameters:</p> <ul> <li> <code>fasta_file</code>               (<code>str</code>)           \u2013            <p>The path to the FASTA file to embed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, list[dict[str, Any]]]</code>           \u2013            <p>A dictionary of embeddings for each taxonomy level. The dictionary keys are the taxonomy levels, and the values are lists of dictionaries containing the id, embeddings and metadata for each sequence.</p> <p>The shape of the list is <code>(n_samples)</code>, where <code>n_samples</code> is the number of sequences.</p> <p>The keys of the inside dictionaries are: <code>id</code>, <code>vector</code>, and the taxonomy levels (e.g. <code>phylum</code>, <code>class</code>, <code>order</code>, <code>family</code>, <code>genus</code>, <code>species</code>) and other metadata fields present in the FASTA header.</p> <p>The shape of the <code>vector</code> is <code>(n_features)</code>, where <code>n_features</code> is the number of features in the embedding. The number of features for each taxonomy level is:</p> <pre><code>- phylum: 18\n- class: 70\n- order: 231\n- family: 791\n- genus: 3695\n- species: 14742\n</code></pre> <p>The returned data looks like: <pre><code>{\n\"phylum\": [{\"id\": \"seq1\", \"vector\": [0.1, 0.2, ...], \"phylum\": \"Basidiomycota\", ...}, ...],\n\"class\": [{\"id\": \"seq1\", \"vector\": [0.5, 0.6, ...], \"class\": \"Agaricomycetes\", ...}, ...],\n\"order\": [{\"id\": \"seq1\", \"vector\": [0.9, 0.8, ...], \"order\": \"Corticiales\", ...}, ...],\n\"family\": [{\"id\": \"seq1\", \"vector\": [0.3, 0.4, ...], \"family\": \"Corticiaceae\", ...}, ...],\n\"genus\": [{\"id\": \"seq1\", \"vector\": [0.7, 0.8, ...], \"genus\": \"Waitea\", ...}, ...],\n\"species\": [{\"id\": \"seq1\", \"vector\": [0.5, 0.6, ...], \"species\": \"Circinata\", ...}, ...]\n}\n</code></pre></p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; config = ProjectConfig()\n&gt;&gt;&gt; model = MycoAICNNEmbedModel(config)\n&gt;&gt;&gt; embeddings = model.embed(\"dna1.fasta\")\n</code></pre> Source code in <code>src/taxotagger/models.py</code> <pre><code>def embed(self, fasta_file: str) -&gt; dict[str, list[dict[str, Any]]]:\n    \"\"\"Calculate the embeddings for the given FASTA file.\n\n    Args:\n        fasta_file: The path to the FASTA file to embed.\n\n    Returns:\n        A dictionary of embeddings for each taxonomy level.\n            The dictionary keys are the taxonomy levels, and the values are lists of dictionaries\n            containing the id, embeddings and metadata for each sequence.\n\n            The shape of the list is `(n_samples)`, where `n_samples` is the number of sequences.\n\n            The keys of the inside dictionaries are: `id`, `vector`, and the taxonomy levels\n            (e.g. `phylum`, `class`, `order`, `family`, `genus`, `species`) and other metadata\n            fields present in the FASTA header.\n\n            The shape of the `vector` is `(n_features)`, where `n_features` is the number of\n            features in the embedding. The number of features for each taxonomy level is:\n\n                - phylum: 18\n                - class: 70\n                - order: 231\n                - family: 791\n                - genus: 3695\n                - species: 14742\n\n            The returned data looks like:\n            ```python\n            {\n            \"phylum\": [{\"id\": \"seq1\", \"vector\": [0.1, 0.2, ...], \"phylum\": \"Basidiomycota\", ...}, ...],\n            \"class\": [{\"id\": \"seq1\", \"vector\": [0.5, 0.6, ...], \"class\": \"Agaricomycetes\", ...}, ...],\n            \"order\": [{\"id\": \"seq1\", \"vector\": [0.9, 0.8, ...], \"order\": \"Corticiales\", ...}, ...],\n            \"family\": [{\"id\": \"seq1\", \"vector\": [0.3, 0.4, ...], \"family\": \"Corticiaceae\", ...}, ...],\n            \"genus\": [{\"id\": \"seq1\", \"vector\": [0.7, 0.8, ...], \"genus\": \"Waitea\", ...}, ...],\n            \"species\": [{\"id\": \"seq1\", \"vector\": [0.5, 0.6, ...], \"species\": \"Circinata\", ...}, ...]\n            }\n            ```\n\n    Examples:\n        &gt;&gt;&gt; config = ProjectConfig()\n        &gt;&gt;&gt; model = MycoAICNNEmbedModel(config)\n        &gt;&gt;&gt; embeddings = model.embed(\"dna1.fasta\")\n    \"\"\"\n    headers, encoded_data = self.parse_and_encode_fasta(fasta_file)\n    # headers shape (n_samples, n_headers), e.g.\n    # [['id1', 'phylum1', 'class1', 'order1', 'family1', 'genus1', 'species1', 'SH_id1'], ...]\n\n    embeddings = []\n    dataloader = DataLoader(encoded_data, shuffle=False)\n    with torch.no_grad():\n        for x, _ in dataloader:  # (encoded data, labels)\n            y_pred = self.model(x.to(self._config.device))\n            embeddings.append(y_pred)\n    # embeddings shape (n_samples, n_taxonomies, (1, n_features)), where n_taxonomies is 6, e.g.\n    # [[phylumTensor1, classTensor1, orderTensor1, familyTensor1, genusTensor1, speciesTensor1], ...]\n    # the shape of each tensor is (1, n_features), n_features are different for each taxonomy level\n\n    data_collections = {}\n    for i, taxo_level in enumerate(TAXONOMY_LEVELS):\n        data_list = [\n            {\n                \"id\": headers[j][0],\n                # squeeze to remove the batch dimension: (1, n_features) -&gt; (n_features)\n                \"vector\": embeddings[j][i].squeeze().numpy(),\n                taxo_level: headers[j][i + 2],\n                \"SH_id\": headers[j][-1],\n            }\n            for j in range(len(embeddings))\n        ]\n        data_collections[taxo_level] = data_list\n    return data_collections\n</code></pre>"},{"location":"api/models/#taxotagger.models.MycoAICNNEmbedModel.parse_and_encode_fasta","title":"parse_and_encode_fasta","text":"<pre><code>parse_and_encode_fasta(\n    fasta_file: str,\n) -&gt; tuple[list[list[str]], TensorData]\n</code></pre> <p>Parse headers and encode the sequences in the given FASTA file.</p> <p>The sequences are encoded using the encoders defined in the pretrained model.</p> <p>Parameters:</p> <ul> <li> <code>fasta_file</code>               (<code>str</code>)           \u2013            <p>The path to the FASTA file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[list[list[str]], TensorData]</code>           \u2013            <p>A tuple containing the headers and the encoded data for the sequences in the FASTA file.</p> <p>The shape of the headers is <code>(n_samples, n_headers)</code>, where <code>n_samples</code> is the number of sequences and <code>n_headers</code> is the 9 metadata fields parsed from the header.</p> </li> </ul> Source code in <code>src/taxotagger/models.py</code> <pre><code>def parse_and_encode_fasta(self, fasta_file: str) -&gt; tuple[list[list[str]], data.TensorData]:\n    \"\"\"Parse headers and encode the sequences in the given FASTA file.\n\n    The sequences are encoded using the encoders defined in the pretrained model.\n\n    Args:\n        fasta_file: The path to the FASTA file.\n\n    Returns:\n        A tuple containing the headers and the encoded data for the sequences in the FASTA file.\n\n            The shape of the headers is `(n_samples, n_headers)`, where `n_samples` is the\n            number of sequences and `n_headers` is the 9 metadata fields parsed from the header.\n    \"\"\"\n    input_data = data.Data(fasta_file, tax_parser=None, allow_duplicates=False)\n    # Using custom parser to parse the FASTA headers\n    headers = [parse_unite_fasta_header(header) for header in input_data.data[\"id\"].values]\n    encoded_data = input_data.encode_dataset(self.model.dna_encoder, self.model.tax_encoder)\n    return headers, encoded_data\n</code></pre>"},{"location":"api/models/#taxotagger.models.MycoAIBERTEmbedModel","title":"MycoAIBERTEmbedModel","text":"<pre><code>MycoAIBERTEmbedModel(config: ProjectConfig)\n</code></pre> <p>               Bases: <code>EmbedModelBase</code></p> <p>Embedding model for the pretrained MycoAI-BERT.</p> Source code in <code>src/taxotagger/models.py</code> <pre><code>def __init__(self, config: ProjectConfig) -&gt; None:\n    self._config = config\n    self.model = load_model(self.name, config)\n</code></pre>"},{"location":"api/models/#taxotagger.models.MycoAIBERTEmbedModel.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'MycoAI-BERT'\n</code></pre>"},{"location":"api/models/#taxotagger.models.MycoAIBERTEmbedModel.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = load_model(name, config)\n</code></pre>"},{"location":"api/models/#taxotagger.models.MycoAIBERTEmbedModel.embed","title":"embed","text":"<pre><code>embed(fasta_file: str) -&gt; dict[str, list[dict[str, Any]]]\n</code></pre> <p>Calculate the embeddings for the given FASTA file.</p> <p>Parameters:</p> <ul> <li> <code>fasta_file</code>               (<code>str</code>)           \u2013            <p>The path to the FASTA file to embed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, list[dict[str, Any]]]</code>           \u2013            <p>A dictionary of embeddings for each taxonomy level. The dictionary keys are the taxonomy levels, and the values are lists of dictionaries containing the id, embeddings and metadata for each sequence.</p> <p>The shape of the list is <code>(n_samples)</code>, where <code>n_samples</code> is the number of sequences.</p> <p>The keys of the inside dictionaries are: <code>id</code>, <code>vector</code>, and the taxonomy levels (e.g. <code>phylum</code>, <code>class</code>, <code>order</code>, <code>family</code>, <code>genus</code>, <code>species</code>) and other metadata fields present in the FASTA header.</p> <p>The shape of the <code>vector</code> is <code>(n_features)</code>, where <code>n_features</code> is the number of features in the embedding. The number of features for each taxonomy level is:</p> <pre><code>- phylum: 18\n- class: 70\n- order: 231\n- family: 791\n- genus: 3695\n- species: 14742\n</code></pre> <p>The returned data looks like: <pre><code>{\n\"phylum\": [{\"id\": \"seq1\", \"vector\": [0.1, 0.2, ...], \"phylum\": \"Basidiomycota\", ...}, ...],\n\"class\": [{\"id\": \"seq1\", \"vector\": [0.5, 0.6, ...], \"class\": \"Agaricomycetes\", ...}, ...],\n\"order\": [{\"id\": \"seq1\", \"vector\": [0.9, 0.8, ...], \"order\": \"Corticiales\", ...}, ...],\n\"family\": [{\"id\": \"seq1\", \"vector\": [0.3, 0.4, ...], \"family\": \"Corticiaceae\", ...}, ...],\n\"genus\": [{\"id\": \"seq1\", \"vector\": [0.7, 0.8, ...], \"genus\": \"Waitea\", ...}, ...],\n\"species\": [{\"id\": \"seq1\", \"vector\": [0.5, 0.6, ...], \"species\": \"Circinata\", ...}, ...]\n}\n</code></pre></p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; config = ProjectConfig()\n&gt;&gt;&gt; model = MycoAIBERTEmbedModel(config)\n&gt;&gt;&gt; embeddings = model.embed(\"dna1.fasta\")\n</code></pre> Source code in <code>src/taxotagger/models.py</code> <pre><code>def embed(self, fasta_file: str) -&gt; dict[str, list[dict[str, Any]]]:\n    \"\"\"Calculate the embeddings for the given FASTA file.\n\n    Args:\n        fasta_file: The path to the FASTA file to embed.\n\n    Returns:\n        A dictionary of embeddings for each taxonomy level.\n            The dictionary keys are the taxonomy levels, and the values are lists of dictionaries\n            containing the id, embeddings and metadata for each sequence.\n\n            The shape of the list is `(n_samples)`, where `n_samples` is the number of sequences.\n\n            The keys of the inside dictionaries are: `id`, `vector`, and the taxonomy levels\n            (e.g. `phylum`, `class`, `order`, `family`, `genus`, `species`) and other metadata\n            fields present in the FASTA header.\n\n            The shape of the `vector` is `(n_features)`, where `n_features` is the number of\n            features in the embedding. The number of features for each taxonomy level is:\n\n                - phylum: 18\n                - class: 70\n                - order: 231\n                - family: 791\n                - genus: 3695\n                - species: 14742\n\n            The returned data looks like:\n            ```python\n            {\n            \"phylum\": [{\"id\": \"seq1\", \"vector\": [0.1, 0.2, ...], \"phylum\": \"Basidiomycota\", ...}, ...],\n            \"class\": [{\"id\": \"seq1\", \"vector\": [0.5, 0.6, ...], \"class\": \"Agaricomycetes\", ...}, ...],\n            \"order\": [{\"id\": \"seq1\", \"vector\": [0.9, 0.8, ...], \"order\": \"Corticiales\", ...}, ...],\n            \"family\": [{\"id\": \"seq1\", \"vector\": [0.3, 0.4, ...], \"family\": \"Corticiaceae\", ...}, ...],\n            \"genus\": [{\"id\": \"seq1\", \"vector\": [0.7, 0.8, ...], \"genus\": \"Waitea\", ...}, ...],\n            \"species\": [{\"id\": \"seq1\", \"vector\": [0.5, 0.6, ...], \"species\": \"Circinata\", ...}, ...]\n            }\n            ```\n\n    Examples:\n        &gt;&gt;&gt; config = ProjectConfig()\n        &gt;&gt;&gt; model = MycoAIBERTEmbedModel(config)\n        &gt;&gt;&gt; embeddings = model.embed(\"dna1.fasta\")\n    \"\"\"\n    headers, encoded_data = self.parse_and_encode_fasta(fasta_file)\n    # headers shape (n_samples, n_headers), e.g.\n    # [['id1', 'phylum1', 'class1', 'order1', 'family1', 'genus1', 'species1', 'SH_id1'], ...]\n\n    embeddings = []\n    dataloader = DataLoader(encoded_data, shuffle=False)\n    with torch.no_grad():\n        for x, _ in dataloader:  # (encoded data, labels)\n            y_pred = self.model(x.to(self._config.device))\n            embeddings.append(y_pred)\n    # embeddings shape (n_samples, n_taxonomies, (1, n_features)), where n_taxonomies is 6, e.g.\n    # [[phylumTensor1, classTensor1, orderTensor1, familyTensor1, genusTensor1, speciesTensor1], ...]\n    # the shape of each tensor is (1, n_features), n_features are different for each taxonomy level\n\n    data_collections = {}\n    for i, taxo_level in enumerate(TAXONOMY_LEVELS):\n        data_list = [\n            {\n                \"id\": headers[j][0],\n                # squeeze to remove the batch dimension: (1, n_features) -&gt; (n_features)\n                \"vector\": embeddings[j][i].squeeze().numpy(),\n                taxo_level: headers[j][i + 2],\n                \"SH_id\": headers[j][-1],\n            }\n            for j in range(len(embeddings))\n        ]\n        data_collections[taxo_level] = data_list\n    return data_collections\n</code></pre>"},{"location":"api/models/#taxotagger.models.MycoAIBERTEmbedModel.parse_and_encode_fasta","title":"parse_and_encode_fasta","text":"<pre><code>parse_and_encode_fasta(\n    fasta_file: str,\n) -&gt; tuple[list[list[str]], TensorData]\n</code></pre> <p>Parse headers and encode the sequences in the given FASTA file.</p> <p>The sequences are encoded using the encoders defined in the pretrained model.</p> <p>Parameters:</p> <ul> <li> <code>fasta_file</code>               (<code>str</code>)           \u2013            <p>The path to the FASTA file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[list[list[str]], TensorData]</code>           \u2013            <p>A tuple containing the headers and the encoded data for the sequences in the FASTA file.</p> <p>The shape of the headers is <code>(n_samples, n_headers)</code>, where <code>n_samples</code> is the number of sequences and <code>n_headers</code> is the 9 metadata fields parsed from the header.</p> </li> </ul> Source code in <code>src/taxotagger/models.py</code> <pre><code>def parse_and_encode_fasta(self, fasta_file: str) -&gt; tuple[list[list[str]], data.TensorData]:\n    \"\"\"Parse headers and encode the sequences in the given FASTA file.\n\n    The sequences are encoded using the encoders defined in the pretrained model.\n\n    Args:\n        fasta_file: The path to the FASTA file.\n\n    Returns:\n        A tuple containing the headers and the encoded data for the sequences in the FASTA file.\n\n            The shape of the headers is `(n_samples, n_headers)`, where `n_samples` is the\n            number of sequences and `n_headers` is the 9 metadata fields parsed from the header.\n    \"\"\"\n    input_data = data.Data(fasta_file, tax_parser=None, allow_duplicates=False)\n    # Using custom parser to parse the FASTA headers\n    headers = [parse_unite_fasta_header(header) for header in input_data.data[\"id\"].values]\n    encoded_data = input_data.encode_dataset(self.model.dna_encoder, self.model.tax_encoder)\n    return headers, encoded_data\n</code></pre>"},{"location":"api/taxotagger/","title":"TaxoTagger","text":""},{"location":"api/taxotagger/#taxotagger","title":"taxotagger","text":""},{"location":"api/taxotagger/#taxotagger.TaxoTagger","title":"TaxoTagger","text":"<pre><code>TaxoTagger(config: ProjectConfig)\n</code></pre> <p>The taxonomy tagger class.</p> Source code in <code>src/taxotagger/taxotagger.py</code> <pre><code>def __init__(self, config: ProjectConfig) -&gt; None:\n    self._config = config\n    setup_logging(config.log_level, config.log_file, config.log_to_console)\n</code></pre>"},{"location":"api/taxotagger/#taxotagger.TaxoTagger.embed","title":"embed","text":"<pre><code>embed(\n    fasta_file: str, model_id: str = \"MycoAI-CNN\"\n) -&gt; dict[str, list[dict[str, Any]]]\n</code></pre> <p>Embed the DNA sequences in the fasta file using the specified model.</p> <p>This is a wrapper function for the <code>embed</code> method of each embedding model. See the <code>models</code> module for more details for each model.</p> <p>Parameters:</p> <ul> <li> <code>fasta_file</code>               (<code>str</code>)           \u2013            <p>The path to the fasta file.</p> </li> <li> <code>model_id</code>               (<code>str</code>, default:                   <code>'MycoAI-CNN'</code> )           \u2013            <p>The model ID to use for embedding the DNA sequences. Defaults to \"MycoAI-CNN\". Available models see <code>taxotagger.defaults.PRETRAINED_MODELS</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, list[dict[str, Any]]]</code>           \u2013            <p>A dictionary of embeddings for each taxonomy level. The dictionary keys are the taxonomy levels, and the values are lists of dictionaries containing the id, embeddings and metadata for each sequence.</p> <p>The shape of the list is <code>(n_samples)</code>, where <code>n_samples</code> is the number of sequences.</p> <p>The keys of the inside dictionaries are: <code>id</code>, <code>vector</code>, taxonomy levels (<code>phylum</code>, <code>class</code>, <code>order</code>, <code>family</code>, <code>genus</code>, <code>species</code>), and other metadata fields.</p> <p>The shape of the <code>vector</code> is <code>(n_features)</code>, where <code>n_features</code> is the number of features in the embedding.</p> <p>The returned data looks like: <pre><code>{\n\"phylum\": [{\"id\": \"seq1\", \"vector\": [0.1, 0.2, ...], \"phylum\": \"Basidiomycota\", ...}, ...],\n\"class\": [{\"id\": \"seq1\", \"vector\": [0.5, 0.6, ...], \"class\": \"Agaricomycetes\", ...}, ...],\n\"order\": [{\"id\": \"seq1\", \"vector\": [0.9, 0.8, ...], \"order\": \"Corticiales\", ...}, ...],\n\"family\": [{\"id\": \"seq1\", \"vector\": [0.3, 0.4, ...], \"family\": \"Corticiaceae\", ...}, ...],\n\"genus\": [{\"id\": \"seq1\", \"vector\": [0.7, 0.8, ...], \"genus\": \"Waitea\", ...}, ...],\n\"species\": [{\"id\": \"seq1\", \"vector\": [0.5, 0.6, ...], \"species\": \"Circinata\", ...}, ...]\n}\n</code></pre></p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; config = ProjectConfig()\n&gt;&gt;&gt; tagger = TaxoTagger(config)\n&gt;&gt;&gt; embeddings = tagger.embed(\"dna1.fasta\")\n</code></pre> Source code in <code>src/taxotagger/taxotagger.py</code> <pre><code>def embed(\n    self,\n    fasta_file: str,\n    model_id: str = \"MycoAI-CNN\",\n) -&gt; dict[str, list[dict[str, Any]]]:\n    \"\"\"Embed the DNA sequences in the fasta file using the specified model.\n\n    This is a wrapper function for the [`embed` method][taxotagger.abc.EmbedModelBase.embed] of\n    each embedding model. See the [`models` module][taxotagger.models] for more details for each\n    model.\n\n    Args:\n        fasta_file: The path to the fasta file.\n        model_id: The model ID to use for embedding the DNA sequences. Defaults to \"MycoAI-CNN\".\n            Available models see [`taxotagger.defaults.PRETRAINED_MODELS`][taxotagger.defaults.PRETRAINED_MODELS].\n\n    Returns:\n        A dictionary of embeddings for each taxonomy level.\n            The dictionary keys are the [taxonomy levels][taxotagger.defaults.TAXONOMY_LEVELS],\n            and the values are lists of dictionaries containing the id, embeddings and metadata\n            for each sequence.\n\n            The shape of the list is `(n_samples)`, where `n_samples` is the number of sequences.\n\n            The keys of the inside dictionaries are: `id`, `vector`, taxonomy levels (`phylum`,\n            `class`, `order`, `family`, `genus`, `species`), and other metadata fields.\n\n            The shape of the `vector` is `(n_features)`, where `n_features` is the number of\n            features in the embedding.\n\n            The returned data looks like:\n            ```python\n            {\n            \"phylum\": [{\"id\": \"seq1\", \"vector\": [0.1, 0.2, ...], \"phylum\": \"Basidiomycota\", ...}, ...],\n            \"class\": [{\"id\": \"seq1\", \"vector\": [0.5, 0.6, ...], \"class\": \"Agaricomycetes\", ...}, ...],\n            \"order\": [{\"id\": \"seq1\", \"vector\": [0.9, 0.8, ...], \"order\": \"Corticiales\", ...}, ...],\n            \"family\": [{\"id\": \"seq1\", \"vector\": [0.3, 0.4, ...], \"family\": \"Corticiaceae\", ...}, ...],\n            \"genus\": [{\"id\": \"seq1\", \"vector\": [0.7, 0.8, ...], \"genus\": \"Waitea\", ...}, ...],\n            \"species\": [{\"id\": \"seq1\", \"vector\": [0.5, 0.6, ...], \"species\": \"Circinata\", ...}, ...]\n            }\n            ```\n\n    Examples:\n        &gt;&gt;&gt; config = ProjectConfig()\n        &gt;&gt;&gt; tagger = TaxoTagger(config)\n        &gt;&gt;&gt; embeddings = tagger.embed(\"dna1.fasta\")\n    \"\"\"\n    logger.info(\n        f\"Embedding the DNA sequences in [magenta]{fasta_file}[/magenta] using the model [magenta]{model_id}[/magenta]\"\n    )\n    model = ModelFactory.get_model(model_id, self._config)\n    return model.embed(fasta_file)\n</code></pre>"},{"location":"api/taxotagger/#taxotagger.TaxoTagger.search","title":"search","text":"<pre><code>search(\n    fasta_file: str,\n    output_taxonomies: list = [],\n    output_metadata: list = [],\n    model_id: str = \"MycoAI-CNN\",\n    db_name: str = \"\",\n    **kwargs: Any\n) -&gt; dict[str, list[list[dict]]]\n</code></pre> <p>Conduct a semantic search for the DNA sequences in the fasta file.</p> <p>Parameters:</p> <ul> <li> <code>fasta_file</code>               (<code>str</code>)           \u2013            <p>The path to the fasta file.</p> </li> <li> <code>output_taxonomies</code>               (<code>list</code>, default:                   <code>[]</code> )           \u2013            <p>List of taxonomy levels to include in the output. Defaults to all taxonomy levels.</p> </li> <li> <code>output_metadata</code>               (<code>list</code>, default:                   <code>[]</code> )           \u2013            <p>List of metadata fields to include in the output. Defaults to an empty list.</p> </li> <li> <code>model_id</code>               (<code>str</code>, default:                   <code>'MycoAI-CNN'</code> )           \u2013            <p>The model ID to use for embedding the DNA sequences. Defaults to \"MycoAI-CNN\". Available models see <code>taxotagger.defaults.PRETRAINED_MODELS</code>.</p> </li> <li> <code>db_name</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The name of the database to search. Defaults to the model ID.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>search</code> method of the Milvus client. For example:</p> <ul> <li><code>limit</code>: The maximum number of matched results to return. Defaults to 10.</li> <li><code>filter</code>: The filtering condition to filter matched results.</li> <li><code>timeout</code>: The timeout in seconds for the search operation. Defaults to None.</li> </ul> <p>See the <code>search</code> method of the Milvus client for more details: https://milvus.io/api-reference/pymilvus/v2.4.x/MilvusClient/Vector/search.md.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, list[list[dict]]]</code>           \u2013            <p>A dictionary of search results for each taxonomy level defined in <code>output_taxonomies</code>. The dictionary keys are the taxonomy levels, and the values are a list of search results (<code>list[dict]</code>) for each sequence.</p> <p>The search result for one sequence is a list of dictionaries, where the length of the list is the <code>limit</code> you set in the search, by default it is 10, i.e. the top 10 matched results.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; config = ProjectConfig()\n&gt;&gt;&gt; tagger = TaxoTagger(config)\n&gt;&gt;&gt; results = tagger.search(\"dna1.fasta\")\n</code></pre> Source code in <code>src/taxotagger/taxotagger.py</code> <pre><code>def search(\n    self,\n    fasta_file: str,\n    output_taxonomies: list = [],\n    output_metadata: list = [],\n    model_id: str = \"MycoAI-CNN\",\n    db_name: str = \"\",\n    **kwargs: Any,\n) -&gt; dict[str, list[list[dict]]]:\n    \"\"\"Conduct a semantic search for the DNA sequences in the fasta file.\n\n    Args:\n        fasta_file: The path to the fasta file.\n        output_taxonomies: List of taxonomy levels to include in the output. Defaults to all taxonomy levels.\n        output_metadata: List of metadata fields to include in the output. Defaults to an empty list.\n        model_id: The model ID to use for embedding the DNA sequences. Defaults to \"MycoAI-CNN\".\n            Available models see [`taxotagger.defaults.PRETRAINED_MODELS`][taxotagger.defaults.PRETRAINED_MODELS].\n        db_name: The name of the database to search. Defaults to the model ID.\n        kwargs: Additional keyword arguments to pass to the `search` method of the Milvus client.\n            For example:\n\n            - `limit`: The maximum number of matched results to return. Defaults to 10.\n            - `filter`: The filtering condition to filter matched results.\n            - `timeout`: The timeout in seconds for the search operation. Defaults to None.\n\n            See the `search` method of the Milvus client for more details:\n            https://milvus.io/api-reference/pymilvus/v2.4.x/MilvusClient/Vector/search.md.\n\n    Returns:\n        A dictionary of search results for each taxonomy level defined in `output_taxonomies`.\n            The dictionary keys are the taxonomy levels, and the values are a list of search\n            results (`list[dict]`) for each sequence.\n\n            The search result for one sequence is a list of dictionaries, where the length of\n            the list is the `limit` you set in the search, by default it is 10, i.e. the top 10\n            matched results.\n\n    Examples:\n        &gt;&gt;&gt; config = ProjectConfig()\n        &gt;&gt;&gt; tagger = TaxoTagger(config)\n        &gt;&gt;&gt; results = tagger.search(\"dna1.fasta\")\n    \"\"\"\n    # Remove `collection_name`, `data` or `output_fields` from  kwargs if they are present\n    kwargs = {\n        k: v for k, v in kwargs.items() if k not in [\"collection_name\", \"data\", \"output_fields\"]\n    }\n\n    # Get the embeddings for the query\n    embeddings = self.embed(fasta_file, model_id)\n\n    #  Get output fields\n    output_taxonomies = self._validate_taxonomies(output_taxonomies)\n    output_taxonomies = output_taxonomies if output_taxonomies else list(TAXONOMY_LEVELS)\n    if not output_taxonomies:\n        output_taxonomies = list(TAXONOMY_LEVELS)\n    output_fields = output_taxonomies + output_metadata\n\n    db_name = db_name if db_name else f\"{model_id}.db\"\n    db_path = os.path.join(self._config.mycoai_home, db_name)\n    # TODO: Check if the database exists and download it if it does not exist\n\n    logger.info(\n        f\"Searching the DNA sequences in [magenta]{fasta_file}[/magenta] in the database {db_path}\"\n    )\n    client = MilvusClient(db_path)\n    results = {}\n    for taxo_level in output_taxonomies:\n        logger.debug(f\"Searching in the collection [blue]{taxo_level}[/blue]\")\n\n        # Prepare input data for the search\n        data = [d[\"vector\"] for d in embeddings[taxo_level]]\n\n        size_of_data, num_items, items_per_batch = self._get_batch_params(data)\n        logger.debug(\n            f\"Embeddings for {taxo_level}: {size_of_data / (1024*1024):.1f} MB, \"\n            f\"{num_items} items in total, {items_per_batch} items per batch\"\n        )\n\n        results_batch = []\n        for i in range(0, num_items, items_per_batch):\n            res = client.search(\n                collection_name=taxo_level,\n                data=data[i : i + items_per_batch],\n                output_fields=output_fields,\n                **kwargs,\n            )\n            results_batch += res\n\n        results[taxo_level] = results_batch\n    client.close()\n\n    return results\n</code></pre>"},{"location":"api/taxotagger/#taxotagger.TaxoTagger.create_db","title":"create_db","text":"<pre><code>create_db(\n    fasta_file: str,\n    model_id: str = \"MycoAI-CNN\",\n    db_name: str = \"\",\n) -&gt; None\n</code></pre> <p>Create a vector database for the DNA sequences in the fasta file with Milvus.</p> <p>Parameters:</p> <ul> <li> <code>fasta_file</code>               (<code>str</code>)           \u2013            <p>The path to the fasta file.</p> </li> <li> <code>model_id</code>               (<code>str</code>, default:                   <code>'MycoAI-CNN'</code> )           \u2013            <p>The model ID to use for embedding the DNA sequences. Defaults to \"MycoAI-CNN\". Available models see <code>taxotagger.defaults.PRETRAINED_MODELS</code>.</p> </li> <li> <code>db_name</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The name of the database to create. Defaults to the model ID.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; config = ProjectConfig()\n&gt;&gt;&gt; tagger = TaxoTagger(config)\n&gt;&gt;&gt; tagger.create_db(\"dna.fasta\")\n</code></pre> Source code in <code>src/taxotagger/taxotagger.py</code> <pre><code>def create_db(\n    self,\n    fasta_file: str,\n    model_id: str = \"MycoAI-CNN\",\n    db_name: str = \"\",\n) -&gt; None:\n    \"\"\"Create a vector database for the DNA sequences in the fasta file with Milvus.\n\n    Args:\n        fasta_file: The path to the fasta file.\n        model_id: The model ID to use for embedding the DNA sequences. Defaults to \"MycoAI-CNN\".\n            Available models see [`taxotagger.defaults.PRETRAINED_MODELS`][taxotagger.defaults.PRETRAINED_MODELS].\n        db_name: The name of the database to create. Defaults to the model ID.\n\n    Examples:\n        &gt;&gt;&gt; config = ProjectConfig()\n        &gt;&gt;&gt; tagger = TaxoTagger(config)\n        &gt;&gt;&gt; tagger.create_db(\"dna.fasta\")\n    \"\"\"\n    # Get the embeddings including the headers\n    embeddings = self.embed(fasta_file, model_id)\n\n    # Create the schema and index for the database\n    dims = {\n        taxonomy_level: embeddings[taxonomy_level][0][\"vector\"].shape[0]\n        for taxonomy_level in TAXONOMY_LEVELS\n    }\n    schema_index_dict = self._create_schema_index(dims)\n\n    db_name = db_name if db_name else f\"{model_id}.db\"\n    db_path = os.path.join(self._config.mycoai_home, db_name)\n\n    # Create collections for each taxonomy level\n    logger.info(\n        f\"Creating vector database for the DNA sequences in [magenta]{fasta_file}[/magenta] at {db_path}\"\n    )\n    client = MilvusClient(db_path)\n    for taxo_level in TAXONOMY_LEVELS:\n        schema, index_params = schema_index_dict[taxo_level]\n\n        if client.has_collection(collection_name=taxo_level):\n            client.drop_collection(collection_name=taxo_level)\n\n        client.create_collection(\n            collection_name=taxo_level,\n            schema=schema,\n            index_params=index_params,\n        )\n\n    # Insert the data into the collections\n    for taxo_level in TAXONOMY_LEVELS:\n        logger.debug(f\"Inserting data into the collection [blue]{taxo_level}[/blue]\")\n\n        data = embeddings[taxo_level]\n        size_of_data, num_items, items_per_batch = self._get_batch_params(data)\n        logger.debug(\n            f\"Embeddings for {taxo_level}: {size_of_data / (1024*1024):.1f} MB, \"\n            f\"{num_items} items in total, {items_per_batch} items per batch\"\n        )\n\n        for i in range(0, num_items, items_per_batch):\n            client.insert(collection_name=taxo_level, data=data[i : i + items_per_batch])\n\n    client.close()\n    logger.info(f\"Database created successfully at {db_path}\")\n</code></pre>"},{"location":"api/utils/","title":"Utilities","text":""},{"location":"api/utils/#taxotagger.utils","title":"taxotagger.utils","text":""},{"location":"api/utils/#taxotagger.utils.download_from_url","title":"download_from_url","text":"<pre><code>download_from_url(\n    url: str,\n    root: str | PathLike,\n    overwrite_existing: bool = False,\n    http_method: str = \"GET\",\n    allow_http_redirect: bool = True,\n) -&gt; str\n</code></pre> <p>Download data from the given URL.</p> <p>The output file name is determined by the URL and saved to the given <code>root</code> directory.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>The URL of the file to download.</p> </li> <li> <code>root</code>               (<code>str | PathLike</code>)           \u2013            <p>The directory to save the file to.</p> </li> <li> <code>overwrite_existing</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite the existing file. Defaults to False.</p> </li> <li> <code>http_method</code>               (<code>str</code>, default:                   <code>'GET'</code> )           \u2013            <p>The HTTP method to use. Defaults to \"GET\".</p> </li> <li> <code>allow_http_redirect</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to allow HTTP redirects. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The path to the downloaded file.</p> </li> </ul> <p>Examples:</p> <p>Download the MycoAI-CNN model to the current directory</p> <pre><code>&gt;&gt;&gt; url = \"https://zenodo.org/records/10904344/files/MycoAI-CNN.pt\"\n&gt;&gt;&gt; download_model(url, \".\")\n</code></pre> Source code in <code>src/taxotagger/utils.py</code> <pre><code>def download_from_url(\n    url: str,\n    root: str | PathLike,\n    overwrite_existing: bool = False,\n    http_method: str = \"GET\",\n    allow_http_redirect: bool = True,\n) -&gt; str:\n    \"\"\"Download data from the given URL.\n\n    The output file name is determined by the URL and saved to the given `root` directory.\n\n    Args:\n        url: The URL of the file to download.\n        root: The directory to save the file to.\n        overwrite_existing: Whether to overwrite the existing file. Defaults to False.\n        http_method: The HTTP method to use. Defaults to \"GET\".\n        allow_http_redirect: Whether to allow HTTP redirects. Defaults to True.\n\n    Returns:\n        The path to the downloaded file.\n\n    Examples:\n        Download the MycoAI-CNN model to the current directory\n        &gt;&gt;&gt; url = \"https://zenodo.org/records/10904344/files/MycoAI-CNN.pt\"\n        &gt;&gt;&gt; download_model(url, \".\")\n    \"\"\"\n    fpath = Path(root) / Path(url).name\n\n    if fpath.exists() and not overwrite_existing:\n        return str(fpath)\n\n    with open(fpath, \"wb\") as fh:\n        with httpx.stream(http_method, url, follow_redirects=allow_http_redirect) as response:\n            response.raise_for_status()\n            print(f\"Downloading {url} to {root}\")\n            total = int(response.headers.get(\"Content-Length\", 0))\n\n            with Progress() as progress:\n                task = progress.add_task(f\"[hot_pink]Downloading {fpath.name}\", total=total)\n                for chunk in response.iter_bytes():\n                    fh.write(chunk)\n                    progress.update(task, advance=len(chunk))\n\n    return str(fpath)\n</code></pre>"},{"location":"api/utils/#taxotagger.utils.load_model","title":"load_model","text":"<pre><code>load_model(model_id: str, config: ProjectConfig) -&gt; Any\n</code></pre> <p>Load the pretrained model with pytorch for the given model identifier.</p> <p>Available models are defined in the default <code>PRETRAINED_MODELS</code>. If the model <code>{model_id}.pt</code> is not found in the cache, it will be downloaded from the predefined URL.</p> <p>Parameters:</p> <ul> <li> <code>model_id</code>               (<code>str</code>)           \u2013            <p>The identifier of the model to load.</p> </li> <li> <code>config</code>               (<code>ProjectConfig</code>)           \u2013            <p>The configurations for the project.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The pretrained model loaded with <code>torch.load</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; config = Config()\n&gt;&gt;&gt; model = load_model(\"MycoAI-CNN\", config)\n</code></pre> Source code in <code>src/taxotagger/utils.py</code> <pre><code>def load_model(\n    model_id: str,\n    config: ProjectConfig,\n) -&gt; Any:\n    \"\"\"Load the pretrained model with pytorch for the given model identifier.\n\n    Available models are defined in the default\n    [`PRETRAINED_MODELS`][taxotagger.defaults.PRETRAINED_MODELS].\n    If the model `{model_id}.pt` is not found in the cache, it will be downloaded from the\n    predefined URL.\n\n    Args:\n        model_id: The identifier of the model to load.\n        config: The configurations for the project.\n\n    Returns:\n        The pretrained model loaded with `torch.load`.\n\n    Examples:\n        &gt;&gt;&gt; config = Config()\n        &gt;&gt;&gt; model = load_model(\"MycoAI-CNN\", config)\n    \"\"\"\n    # validate the model id\n    if model_id not in PRETRAINED_MODELS:\n        raise ValueError(\n            f\"Invalid model id {model_id}. Available models are {PRETRAINED_MODELS.keys()}\"\n        )\n\n    # use cache or download the model\n    model_dir = config.mycoai_home\n    os.makedirs(model_dir, exist_ok=True)\n    model_path = Path(model_dir) / f\"{model_id}.pt\"\n    if not model_path.exists() or config.force_reload:\n        download_from_url(PRETRAINED_MODELS[model_id], model_dir, config.force_reload)\n\n    logger.info(f\"Loading model [magenta]{model_id}[/magenta] from {model_path}\")\n    model = torch.load(model_path, map_location=config.device)\n    return model\n</code></pre>"},{"location":"api/utils/#taxotagger.utils.parse_fasta","title":"parse_fasta","text":"<pre><code>parse_fasta(data: str | PathLike | TextIO) -&gt; dict\n</code></pre> <p>Parse  FASTA data and return a dictionary of sequences.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>str | PathLike | TextIO</code>)           \u2013            <p>Can be one of the following:</p> <ul> <li>A file-like object (with .read() or .readline() methods)</li> <li>A file path (string or PathLike) to a FASTA file</li> <li>A string containing FASTA content</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary with the FASTA headers as keys and the sequences as values.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If there are duplicate FASTA headers.</p> </li> </ul> Source code in <code>src/taxotagger/utils.py</code> <pre><code>def parse_fasta(data: str | PathLike | TextIO) -&gt; dict:\n    \"\"\"Parse  FASTA data and return a dictionary of sequences.\n\n    Args:\n        data: Can be one of the following:\n\n            - A file-like object (with .read() or .readline() methods)\n            - A file path (string or PathLike) to a FASTA file\n            - A string containing FASTA content\n\n    Returns:\n        A dictionary with the FASTA headers as keys and the sequences as values.\n\n    Raises:\n        ValueError: If there are duplicate FASTA headers.\n    \"\"\"\n    id_seq_dict = {}\n\n    fh = _fasta_to_handle(data)\n    for record in SeqIO.parse(fh, \"fasta\"):\n        if record.id not in id_seq_dict:\n            id_seq_dict[record.id] = str(record.seq)\n        else:\n            raise ValueError(f\"Duplicate FASTA header found: `{record.id}`\")\n    return id_seq_dict\n</code></pre>"},{"location":"api/utils/#taxotagger.utils.parse_unite_fasta_header","title":"parse_unite_fasta_header","text":"<pre><code>parse_unite_fasta_header(header: str) -&gt; list[str]\n</code></pre> <p>Parse metadata from a UNITE FASTA file header.</p> <p>The header of a FASTA file must follow the formats:</p> <ul> <li>the UNITE format:     <pre><code>&gt;Accession|k__Kingdom;p__Phylum;c__Class;o__Order;f__Family;g__Genus;s__Species|SHIdentifier\n</code></pre></li> <li>only the accession:     <pre><code>&gt;Accession\n</code></pre></li> </ul> <p>Note that the <code>SHIdentifier</code> (Species Hypothesis identifier) is optional.</p> <p>Parameters:</p> <ul> <li> <code>header</code>               (<code>str</code>)           \u2013            <p>A string representing the header of a FASTA file from the UNITE database.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>A list of parsed metadata in the following order: <code>[Accession, Kingdom, Phylum, Class, Order, Family, Genus, Species, SH_ID]</code>. Empty strings are returned for missing metadata.</p> </li> </ul> <p>Examples:</p> <p>Parse the header of a UNITE FASTA file</p> <pre><code>&gt;&gt;&gt; header = \"&gt;MH855962|k__Fungi;p__Basidiomycota;c__Agaricomycetes;o__Corticiales;f__Corticiaceae;g__Waitea;s__Waitea_circinata|SH1011630.09FU\"\n&gt;&gt;&gt; parse_unite_fasta_header(header)\n['MH855962', 'Fungi', 'Basidiomycota', 'Agaricomycetes', 'Corticiales', 'Corticiaceae', 'Waitea', 'Waitea_circinata', 'SH1011630.09FU']\n</code></pre> <p>Parse the header of a FASTA file with only the accession</p> <pre><code>&gt;&gt;&gt; process_unite_fasta_header(\"&gt;MH855962\")\n['MH855962', '', '', '', '', '', '', '', '']\n</code></pre> Source code in <code>src/taxotagger/utils.py</code> <pre><code>def parse_unite_fasta_header(header: str) -&gt; list[str]:\n    \"\"\"Parse metadata from a UNITE FASTA file header.\n\n    The header of a FASTA file must follow the formats:\n\n    - the UNITE format:\n        ```\n        &gt;Accession|k__Kingdom;p__Phylum;c__Class;o__Order;f__Family;g__Genus;s__Species|SHIdentifier\n        ```\n    - only the accession:\n        ```\n        &gt;Accession\n        ```\n\n    Note that the `SHIdentifier` (Species Hypothesis identifier) is optional.\n\n    Args:\n        header: A string representing the header of a FASTA file from the UNITE database.\n\n    Returns:\n        A list of parsed metadata in the following order:\n            `[Accession, Kingdom, Phylum, Class, Order, Family, Genus, Species, SH_ID]`.\n            Empty strings are returned for missing metadata.\n\n    Examples:\n        Parse the header of a UNITE FASTA file\n        &gt;&gt;&gt; header = \"&gt;MH855962|k__Fungi;p__Basidiomycota;c__Agaricomycetes;o__Corticiales;f__Corticiaceae;g__Waitea;s__Waitea_circinata|SH1011630.09FU\"\n        &gt;&gt;&gt; parse_unite_fasta_header(header)\n        ['MH855962', 'Fungi', 'Basidiomycota', 'Agaricomycetes', 'Corticiales', 'Corticiaceae', 'Waitea', 'Waitea_circinata', 'SH1011630.09FU']\n\n        Parse the header of a FASTA file with only the accession\n        &gt;&gt;&gt; process_unite_fasta_header(\"&gt;MH855962\")\n        ['MH855962', '', '', '', '', '', '', '', '']\n    \"\"\"\n    result = [\"\"] * 9\n\n    # Split the header into sections based on '|'\n    header = header.lstrip(\"&gt;\")\n    sections = header.split(\"|\")\n\n    # The accession is the first part\n    result[0] = sections[0]\n\n    # If there is a taxonomy section, process it\n    if len(sections) &gt; 1:\n        taxonomy_parts = sections[1].split(\";\")\n        taxonomy_map = {\n            \"k__\": 1,  # Kingdom\n            \"p__\": 2,  # Phylum\n            \"c__\": 3,  # Class\n            \"o__\": 4,  # Order\n            \"f__\": 5,  # Family\n            \"g__\": 6,  # Genus\n            \"s__\": 7,  # Species\n        }\n        for part in taxonomy_parts:\n            prefix, value = part[:3], part[3:]\n            if prefix in taxonomy_map:\n                result[taxonomy_map[prefix]] = value\n\n    # If there is an SH ID section, add it\n    if len(sections) &gt; 2:\n        result[8] = sections[2]\n\n    return result\n</code></pre>"},{"location":"guide/custom_models/","title":"Custom Embedding Models","text":"<p>One of the key features of TaxoTagger is the ability to use custom embedding models. This allows users to use their own models or models from other sources to calculate the embeddings for the given FASTA file. </p> <p>TaxoTagger comes with a few pre-trained models, but users can add their own models to the tool. For this, users need to follow the steps below.</p> <p>Model format</p> <p>Currently, TaxoTagger only supports PyTorch models. If you have a model in another framework, you could convert it to PyTorch before using it with TaxoTagger. </p>"},{"location":"guide/custom_models/#1-register-your-custom-embedding-model-in-the-pretrained_models-dictionary","title":"1. Register your custom embedding model in the <code>PRETRAINED_MODELS</code> dictionary","text":"<p>The name of the models are the keys of the dictionary, and the values are the download URLs. </p> <p>The model names should be unique and should not contain any spaces. The download URLs should be direct download links to the model files. Most importantly, the name of the downloaded file should be the same as the model name, with the extension <code>.pt</code>.</p> <p>For example, your custom model is named <code>Example-Transformer</code>, and the model files should be named <code>Example-Transformer.pt</code>, then you can add the following entry to the <code>PRETRAINED_MODELS</code> dictionary:</p> <pre><code>PRETRAINED_MODELS = {\n    \"MycoAI-CNN\": \"https://zenodo.org/records/10904344/files/MycoAI-CNN.pt\",\n    \"MycoAI-BERT\": \"https://zenodo.org/records/10904344/files/MycoAI-BERT.pt\",\n    \"Example-Transformer\": \"https://example.com/Example-Transformer.pt\"\n}\n</code></pre>"},{"location":"guide/custom_models/#2-implement-a-new-wrapper-class-for-the-embedding-model","title":"2. Implement a new wrapper class for the embedding model","text":"<p>Add a new wrapper class for the embedding model to the <code>taxotagger.models</code> module (source code file). The wrapper class should inherit from the <code>EmbedModelBase</code> abstract class and implement the <code>embed</code>method to calculate the embeddings for the given FASTA file.</p> <p>Here is an example of a custom embedding model wrapper class:</p> <pre><code># For clarity, we omitted the imports and other parts of the code, e.g. docstring\n\ndef ExampleTransformerEmbedModel(EmbedModelBase): \n\n    name = \"Example-Transformer\" # (1)!\n\n    def __init__(self, config: ProjectConfig) -&gt; None: # (2)!\n        self._config = config\n        self.model = load_model(self.name, config)\n\n    def embed(self, fasta_file: str) -&gt; dict[str, list[dict[str, Any]]]: # (3)!\n        # Parse input FASTA file\n        sequences = read_fasta(fasta_file)\n        # Calculate embeddings\n        embeddings = self.model(sequences)\n        # Return the embeddings\n        return embeddings\n</code></pre> <ol> <li>It's important to set the <code>name</code> attribute to the name of the model.</li> <li>It's  recommended to add a constructor to the class to load the model. </li> <li>The <code>embed</code> method should calculate the embeddings for the given FASTA file and return them as a dictionary. The logic for calculating the embeddings is specific to the model, and you should implement it accordingly.</li> </ol>"},{"location":"guide/custom_models/#3-add-the-new-wrapper-class-to-the-modelfactoryget_model-method","title":"3. Add the new wrapper class to the <code>ModelFactory.get_model</code> method","text":"<p>After implementing the new wrapper class, you need to add it to the <code>ModelFactory.get_model</code> method (source code file). This method should return the wrapper class for the given model name.</p> <p>Here is an example for adding the new wrapper class <code>ExampleTransformerEmbedModel</code>:</p> <pre><code>class ModelFactory:\n    \"\"\"Factory class to get the embedding model for the given model identifier.\"\"\"\n\n    @staticmethod\n    def get_model(model_id: str, config: ProjectConfig) -&gt; EmbedModelBase:\n        \"\"\"Get the embedding model for the given model identifier.\n\n        Args:\n            model_id: The identifier of the model to load.\n            config: The configurations for the project.\n\n        Returns:\n            The embedding model instance for the given model identifier.\n\n        Examples:\n            &gt;&gt;&gt; config = ProjectConfig()\n            &gt;&gt;&gt; model = ModelFactory.get_model(\"MycoAI-CNN\", config)\n        \"\"\"\n        if model_id == \"MycoAI-CNN\":\n            return MycoAICNNEmbedModel(config)\n        elif model_id == \"MycoAI-BERT\":\n            return MycoAIBERTEmbedModel(config)\n        elif model_id == \"Example-Transformer\": # (1)!\n            return ExampleTransformerEmbedModel(config) # (2)!\n        # Add more embedding models here if needed\n        else:\n            raise ValueError(\n                f\"Invalid model id {model_id}. Valid models are {PRETRAINED_MODELS.keys()}\"\n            )\n</code></pre> <ol> <li>Add the new model name to the <code>ModelFactory.get_model</code> method.</li> <li>Return the new wrapper class for the given model name.</li> </ol>"},{"location":"guide/custom_models/#4-test-the-custom-embedding-model","title":"4. Test the custom embedding model","text":"<p>Implement a test case for the custom embedding model to ensure that it works correctly. You can add the unit tests to the file <code>test_models.py</code>.</p>"},{"location":"guide/custom_models/#5-submit-a-pull-request-or-build-your-own-version-of-taxotagger","title":"5. Submit a pull request or build your own version of TaxoTagger","text":"<p>You can submit a pull request to the TaxoTagger repository to add your custom embedding model to the tool. Alternatively, you can build your own version of TaxoTagger with the custom embedding model and use it for your projects.</p>"},{"location":"guide/logging/","title":"How to setup logging","text":"<p>TaxoTagger uses the standard library logging  module for managing log messages and the python library rich  to colorize the log messages. Depending on how you use TaxoTagger, you can set up logging in different ways.</p>"},{"location":"guide/logging/#taxotagger-as-an-application","title":"TaxoTagger as an application","text":"<p>If you're using TaxoTagger as an application, you are using the <code>TaxoTagger</code> class,  like the example described in the Quickstart. In this case, you can set up logging with the configuration. </p>"},{"location":"guide/logging/#taxotagger-as-a-library","title":"TaxoTagger as a library","text":"<p>If you're using TaxoTagger as a library, you're using some other functions or classes in your script.  By default, TaxoTagger will not log any messages. However, you can set up logging in your script with  the <code>setup_logging</code> function:</p> Set up logging in 'your_script.py'<pre><code># Set up logging configuration first\nfrom TaxoTagger import setup_logging\n\nsetup_logging(level=\"DEBUG\", file=\"taxotagger.log\", to_console=True) # (1)!\n\n# Your business code here\n# e.g. download a model from the internet to `~/temp_dir` folder\nfrom TaxoTagger.utils import download_from_url\n\nurl = \"https://zenodo.org/records/10904344/files/MycoAI-CNN.pt\"\ndownload_from_url(url, \"~/temp_dir\")\n</code></pre> <ol> <li>The <code>setup_logging</code> function sets up the logging settings:<ul> <li>The <code>level</code> sets the logging level, e.g. <code>NONSET</code>, <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, and <code>CRITICAL</code>.</li> <li>The <code>file</code> sets the path to the log file. </li> <li>The <code>to_console</code> sets whether to log messages to your console.</li> </ul> </li> </ol> <p>Run the script above, you will see the log messages in the console and the log file <code>taxotagger.log</code> in the current working directory.</p>"}]}